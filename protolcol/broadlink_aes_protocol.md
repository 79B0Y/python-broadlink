# Broadlink 设备 AES 会话密钥获取协议文档

## 目标
通过 UDP 在局域网内与 Broadlink 设备进行认证，获取设备分配的会话 AES 密钥。该密钥用于后续所有业务指令的加解密通信。

---

## 通信与加密参数

| 参数 | 值 | 说明 |
|------|-----|------|
| **传输协议** | UDP 单播 | 目标端口 `80` |
| **初始密钥** | `097628343fe99e23765c1513accf8b02` | 16 字节（HEX），认证前使用 |
| **初始 IV** | `562e17996d093d28ddb3ba695a2e6f58` | 16 字节（HEX），认证前后均不变 |
| **加密算法** | AES-CBC | 无 PKCS7 填充，需手动 16 字节对齐 |
| **会话密钥** | 设备认证响应返回 | 16 字节，后续业务指令使用此密钥 |

---

## 外层数据包结构（UDP 载荷）

### 字段定义

| 偏移量 | 长度 | 字段名 | 说明 |
|--------|------|--------|------|
| `0x00` | 8 | **魔数** | 固定值 `5aa5aa555aa5aa55` |
| `0x08` | 18 | **时间戳** | Broadlink 协议时间格式（12 字节）+ 保留 |
| `0x20` | 2 | **整包校验和** | 小端序，见"校验算法" |
| `0x22` | 2 | **错误码** | 小端序，`0x0000` 表示成功 |
| `0x24` | 2 | **设备类型** | 小端序，如 `0x2737` |
| `0x26` | 2 | **指令类型** | 小端序，认证请求为 `0x0065` |
| `0x28` | 2 | **计数器** | 小端序，每次递增：`(count+1) | 0x8000` |
| `0x2A` | 6 | **设备 MAC** | **倒序字节**（如 MAC 为 `AA:BB:CC:DD:EE:FF`，写入为 `FF EE DD CC BB AA`） |
| `0x30` | 4 | **设备 ID** | 小端序，认证前填 `0`，成功后使用设备返回值 |
| `0x34` | 2 | **负载校验和** | 小端序，对明文负载计算（见"校验算法"） |
| `0x36` | 2 | **保留** | 填 `0` |
| `0x38` | 变长 | **加密负载** | AES-CBC 加密后的数据（16 字节对齐） |

### 关键说明
- **MAC 倒序**：硬件地址需按字节反转后写入
- **计数器规则**：发送前递增并与 `0x8000` 进行或运算，防止回放攻击
- **设备 ID**：认证前为 `0x00000000`，认证后使用响应中的 ID

---

## 内层负载结构（认证请求）

### packet_type = 0x0065（认证）

固定长度 **0x50 字节**（80 字节），结构如下：

| 偏移量 | 长度 | 内容 | 说明 |
|--------|------|------|------|
| `0x00` | 4 | `00 00 00 00` | 保留 |
| `0x04` | 16 | `31 31 ... 31` | 16 个 `0x31` |
| `0x14` | 10 | `00 00 ... 00` | 填充 |
| `0x1E` | 1 | `0x01` | 标志位 |
| `0x1F` | 14 | `00 00 ... 00` | 填充 |
| `0x2D` | 1 | `0x01` | 标志位 |
| `0x2E` | 2 | `00 00` | 填充 |
| `0x30` | 6 | `54 65 73 74 20 31` | ASCII `"Test 1"` |
| `0x36` | 26 | `00 00 ... 00` | 填充至 0x50 |

**发送前处理**：
1. 计算明文负载的校验和（见"校验算法"）
2. 对负载进行 16 字节对齐（已满足，无需额外填充）
3. 使用初始密钥 `INIT_KEY` 和 `INIT_IV` 进行 AES-CBC 加密

---

## 认证响应解析

### 响应包结构
- 使用与请求相同的外层包格式
- 关键字段：
  - `response[0x22:0x24]`：错误码，`0x0000` 表示成功
  - `response[0x38:]`：加密负载

### 解密响应负载

使用 **初始密钥** `INIT_KEY` 和 `INIT_IV` 解密 `response[0x38:]` 后：

| 偏移量 | 长度 | 字段名 | 说明 |
|--------|------|--------|------|
| `0x00` | 4 | **设备 ID** | 小端序，后续请求必须使用此 ID |
| `0x04` | 16 | **会话 AES Key** | 后续业务指令（packet_type=0x6A 等）的加密密钥 |
| `0x14` | 变长 | **其他数据** | 保留字段 |

**关键操作**：
```python
device_id = int.from_bytes(dec_payload[0x00:0x04], "little")
session_key = bytes(dec_payload[0x04:0x14])
```

---

## 校验算法

### 1. 负载校验和（写入 `packet[0x34:0x36]`）

```python
def checksum16_beaf(buf: bytes) -> int:
    return (sum(buf) + 0xBEAF) & 0xFFFF
```

- 对 **明文负载**（未加密、未填充的实际 payload）逐字节求和
- 加 `0xBEAF`
- 按 `0xFFFF` 截断为 16 位
- 以小端序写入包头

### 2. 整包校验和（写入 `packet[0x20:0x22]`）

```python
# 组装完整数据包后（含加密负载）
checksum = (sum(packet) + 0xBEAF) & 0xFFFF
packet[0x20:0x22] = checksum.to_bytes(2, "little")
```

### 3. 响应校验验证

```python
nom_checksum = int.from_bytes(resp[0x20:0x22], "little")
real_checksum = (sum(resp) + 0xBEAF - sum(resp[0x20:0x22])) & 0xFFFF
if nom_checksum != real_checksum:
    raise ValueError("整包校验失败")
```

---

## 完整交互流程

### 流程图

```
┌─────────┐                                    ┌─────────┐
│ Client  │                                    │ Device  │
└────┬────┘                                    └────┬────┘
     │                                              │
     │  初始化: AES=INIT_KEY, IV=INIT_IV, ID=0     │
     │                                              │
     │  [可选] 1. 单播 Hello (获取 devtype/MAC)    │
     ├─────────────────────────────────────────────>│
     │<─────────────────────────────────────────────┤
     │            返回设备类型和 MAC                │
     │                                              │
     │  2. 构造认证负载 (0x50 字节)                │
     │  3. 计算负载校验和                           │
     │  4. AES-CBC 加密负载                        │
     │  5. 组装外层包 (packet_type=0x65)           │
     │  6. 计算整包校验和                           │
     │                                              │
     │  UDP 发送认证请求 (端口 80)                 │
     ├─────────────────────────────────────────────>│
     │                                              │
     │                                     验证请求  │
     │<─────────────────────────────────────────────┤
     │              返回认证响应                     │
     │                                              │
     │  7. 验证响应校验和                           │
     │  8. 检查错误码 (0x22:0x24)                  │
     │  9. AES-CBC 解密响应负载                    │
     │  10. 提取 device_id 和 session_key         │
     │                                              │
     │  更新本地 AES Key                            │
     │  后续使用 packet_type=0x6A                  │
     │                                              │
```

### 步骤详解

1. **准备阶段**
   - 设置 AES 密钥为 `INIT_KEY`，IV 为 `INIT_IV`
   - 设备 ID 初始化为 `0`
   - 获取设备 `devtype` 和 `MAC`（可通过单播 Hello 或手动指定）

2. **构造请求**
   - 创建 0x50 字节认证负载
   - 计算负载校验和并填入包头 `[0x34:0x36]`
   - 使用初始密钥加密负载（16 字节对齐）
   - 组装外层包头（填入 devtype、MAC 倒序、count、id=0、packet_type=0x65）
   - 计算整包校验和并填入 `[0x20:0x22]`

3. **发送与接收**
   - UDP 发送到设备 `:80`
   - 接收响应（可能需要重试）

4. **解析响应**
   - 验证整包校验和
   - 检查错误码 `response[0x22:0x24]`（必须为 `0x0000`）
   - 使用初始密钥解密 `response[0x38:]`
   - 提取 `device_id`（偏移 0x00）和 `session_key`（偏移 0x04）

5. **会话建立**
   - 更新本地 AES 密钥为 `session_key`
   - IV 保持不变（继续使用 `INIT_IV`）
   - 后续业务指令使用新的 `device_id` 和 `session_key`

---

## 示例工具使用

### 脚本：`examples/get_aes_key.py`

**功能**：
- 自动发现设备类型和 MAC（可选）
- 发送认证请求（packet_type=0x65）
- 解密响应并输出会话密钥

**用法示例**：

```bash
# 1. 自动发现 devtype 和 MAC
python examples/get_aes_key.py --host 192.168.1.16

# 2. 指定本机网卡 IP
python examples/get_aes_key.py --host 192.168.1.16 --ip 192.168.1.100

# 3. 手动提供设备信息
python examples/get_aes_key.py --host 192.168.1.16 \
    --devtype 0x2737 \
    --mac aa:bb:cc:dd:ee:ff

# 4. 自定义端口和超时
python examples/get_aes_key.py --host 192.168.1.16 \
    --port 80 \
    --timeout 15
```

**输出示例**：
```
认证成功：
设备 IP     : 192.168.1.16:80
设备类型    : 0x2737
设备 MAC    : AA/BB/CC/DD/EE/FF
设备 ID     : 0x12345678 (305419896)
会话 AES Key: 3f4a5b6c7d8e9f0a1b2c3d4e5f607182
```

---

## 注意事项与安全建议

### ⚠️ 安全警告
1. **密钥保护**：会话密钥和设备 ID 具有敏感性，避免在日志或网络中明文传输
2. **网络隔离**：建议在隔离的局域网环境中进行测试
3. **抓包风险**：开发调试时注意清理网络抓包文件

### 🔧 故障排查
| 问题 | 检查项 |
|------|--------|
| **超时无响应** | 1. 设备 IP/端口是否正确<br>2. 防火墙规则<br>3. 设备是否在线 |
| **校验失败** | 1. MAC 地址是否倒序<br>2. 负载是否正确加密<br>3. 计数器是否正确递增 |
| **错误码非零** | 查看 `response[0x22:0x24]` 具体值，参考设备文档 |
| **解密失败** | 1. 确认使用初始密钥解密响应<br>2. 检查响应长度（≥ 0x38） |

### 📝 开发提示
- **大小端问题**：所有多字节整数均为小端序（little-endian）
- **MAC 倒序**：这是最容易出错的地方，务必按字节反转
- **计数器管理**：每次请求递增，防止重放攻击
- **IV 不变性**：认证前后 IV 始终为 `INIT_IV`，仅密钥更换
- **16 字节对齐**：加密前必须手动填充至 16 的倍数

---

## 附录

### A. 时间戳格式（12 字节）

Broadlink 协议时间戳结构：

| 偏移量 | 长度 | 字段 | 说明 |
|--------|------|------|------|
| `0x00` | 4 | UTC 偏移 | 小端序，单位：小时（有符号） |
| `0x04` | 2 | 年份 | 小端序，如 2025 → `0xE907` |
| `0x06` | 1 | 分钟 | 0-59 |
| `0x07` | 1 | 小时 | 0-23 |
| `0x08` | 1 | 年份后两位 | 如 2025 → 25 |
| `0x09` | 1 | 星期 | 1=周一, 7=周日 |
| `0x0A` | 1 | 日 | 1-31 |
| `0x0B` | 1 | 月 | 1-12 |

### B. 常见设备类型（devtype）

| 设备类型 | 十六进制 | 十进制 | 说明 |
|----------|----------|--------|------|
| RM Mini 3 | 0x2737 | 10039 | 红外遥控器 |
| RM Pro | 0x2712 | 10002 | 红外/射频遥控器 |
| SP2 | 0x2711 | 10001 | 智能插座 |
| SP3 | 0x947A | 37994 | 智能插座（升级版） |

### C. 常见错误码

| 错误码 | 十六进制 | 说明 |
|--------|----------|------|
| 0 | 0x0000 | 成功 |
| -1 | 0xFFFF | 通用错误 |
| -2 | 0xFFFE | 设备忙碌 |
| -3 | 0xFFFD | 超时 |
| -4 | 0xFFFC | 校验失败 |

---

## 相关资源

- **依赖库**：`cryptography>=3.2`（已包含在 `requirements.txt`）
- **后续指令**：认证成功后可使用 `packet_type=0x6A` 进行业务通信
- **设备发现**：可参考 `unicast_hello()` 函数实现单播发现逻辑

---

**文档版本**：v1.0  
**最后更新**：2025-09-29  
**维护者**：Broadlink Protocol Team